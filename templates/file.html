<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Plan Your Room</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: #e2e8f0;
      font-family: "Inter", sans-serif;
      font-weight: 400;
    }

    #canvas {
      background: radial-gradient(circle at center, #1e293b 0%, #0f172a 80%);
      padding: 2rem;
    }

    #room-container {
      background-color: #1e293b;
      position: relative;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3), 0 0 0 2px #334155;
      border-radius: 12px;
      overflow: hidden;
      transform-origin: center center;
    }

    .furniture {
      position: absolute;
      border: 2px solid transparent;
      border-radius: 8px;
      background-color: rgba(255, 255, 255, 0.04);
      cursor: move;
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      transform-origin: center center;
    }

    .furniture.selected {
      border: 2px solid #3b82f6;
      box-shadow: 0 0 12px rgba(59, 130, 246, 0.6), 0 4px 20px rgba(0,0,0,0.2);
    }

    .furniture img {
      width: auto;
      height: auto;
      object-fit: fill;
      border-radius: 6px;
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1;
    }

    .colliding {
      box-shadow: 0 0 12px rgba(239, 68, 68, 0.8), 0 4px 20px rgba(239, 68, 68, 0.2);
    }

    .handle {
      position: absolute;
      width: 12px;
      height: 12px;
      background-color: #3b82f6;
      border: 2px solid #0f172a;
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      pointer-events: auto;
    }

    .furniture.selected .handle {
      opacity: 1;
    }

    .resize-handle {
      bottom: -6px;
      right: -6px;
      cursor: nwse-resize;
    }

    .rotate-handle {
      top: -24px;
      left: calc(50% - 6px);
      cursor: grab;
      width: 16px;
      height: 16px;
    }

    .rotate-handle:hover {
      background-color: #1d4ed8;
    }

    .rotate-handle.snapped {
      background-color: #22c55e;
    }

    .room-handle {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background-color: #475569;
      border: 2px solid #94a3b8;
      position: absolute;
      transition: all 0.2s ease;
    }

    .room-handle:hover {
      background-color: #3b82f6;
      transform: scale(1.2);
    }

    .room-handle.top-left { top: -6px; left: -6px; cursor: nwse-resize; }
    .room-handle.top-right { top: -6px; right: -6px; cursor: nesw-resize; }
    .room-handle.bottom-left { bottom: -6px; left: -6px; cursor: nesw-resize; }
    .room-handle.bottom-right { bottom: -6px; right: -6px; cursor: nwse-resize; }

    .wall-feature {
      position: absolute;
      cursor: move;
      z-index: 5;
      box-sizing: border-box;
      transition: all 0.2s ease;
      border-radius: 4px;
    }

    .wall-feature img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      opacity: 0.95;
      pointer-events: none;
    }

    .wall-feature.selected {
      box-shadow: 0 0 12px rgba(96, 165, 250, 0.8), 0 4px 20px rgba(0,0,0,0.2);
      border-color: #93c5fd !important;
    }

    .dimension-display {
      position: absolute;
      bottom: -24px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(30, 41, 59, 0.9);
      color: #f1f5f9;
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 500;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    .room-dimension {
      bottom: auto;
      top: -24px;
      right: 0;
      left: auto;
      transform: none;
    }

    #floating-sidebar {
      position: fixed;
      top: 20px;
      left: 20px;
      width: 280px;
      height: 80vh;
      background: rgba(30, 41, 59, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.3);
      z-index: 1000;
      overflow-y: auto;
      transition: transform 0.3s ease;
    }

    #floating-sidebar.hidden {
      transform: translateX(-320px);
    }

    #floating-sidebar-header {
      padding: 16px;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .sidebar-icon {
      background: rgba(255,255,255,0.05);
      border-radius: 8px;
      padding: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: none;
      color: #94a3b8;
      transition: color 0.2s;
      cursor: pointer;
    }

    .sidebar-icon:hover {
      color: #3b82f6;
    }

    .btn {
      border-radius: 8px;
      font-weight: 500;
      padding: 0.75rem 1.25rem;
      transition: all 0.2s ease;
      font-family: "Inter", sans-serif;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      border: none;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 14px;
    }

    #load-btn {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: white;
    }
    #load-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.4);
    }

    #save-btn {
      background: linear-gradient(135deg, #16a34a, #15803d);
      color: white;
    }
    #save-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(22, 163, 74, 0.4);
    }

    #delete-btn {
      background: linear-gradient(135deg, #dc2626, #b91c1c);
      color: white;
    }
    #delete-btn:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(220, 38, 38, 0.4);
    }

    #delete-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }

    .toggle-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(255,255,255,0.05);
      padding: 0.5rem 1rem;
      border-radius: 8px;
      margin-left: auto;
    }

    .toggle-switch {
      position: relative;
      width: 44px;
      height: 24px;
      background: #4b5563;
      border-radius: 12px;
      transition: background 0.2s;
      cursor: pointer;
    }

    .toggle-switch input:checked + .toggle-slider {
      background: #3b82f6;
      transform: translateX(20px);
    }

    .toggle-slider {
      position: absolute;
      top: 2px;
      left: 2px;
      width: 20px;
      height: 20px;
      background: white;
      border-radius: 50%;
      transition: all 0.2s;
    }

    .hide-dims .dimension-display { opacity: 0; }

    #toggle-sidebar {
      z-index: 999;
    }
  </style>
</head>
<body class="font-sans bg-gray-900 text-gray-100">
  <button id="toggle-sidebar" class="fixed top-4 left-4 btn bg-gray-800 text-white rounded-full p-2">
    ðŸ“‹
  </button>

  <div id="floating-sidebar" class="hidden">
    <div id="floating-sidebar-header">
      <h1 class="text-xl font-bold">Catalog</h1>
      <button class="sidebar-icon" id="close-sidebar">âœ•</button>
    </div>
    <div class="p-4 space-y-6 overflow-y-auto">
      <div>
        <h2 class="text-lg font-semibold border-b border-slate-700 pb-2">Furniture</h2>
        <div id="furniture-list" class="space-y-4 mt-2 grid grid-cols-2 gap-2"></div>
      </div>
      <div>
        <h2 class="text-lg font-semibold border-b border-slate-700 pb-2">Architectural</h2>
        <div id="architectural-list" class="space-y-4 mt-2 grid grid-cols-2 gap-2"></div>
      </div>
    </div>
  </div>

  <main class="flex-1 flex flex-col pt-4 pr-4">
    <header class="flex justify-between items-center mb-4 p-4 bg-slate-800/50 rounded-lg">
      <div class="flex items-center space-x-4">
        <h1 class="text-xl font-bold">Room Planner</h1>
      </div>
      <div class="flex items-center space-x-3">
        <div class="toggle-container">
          <span class="text-sm text-slate-300">Show Dims</span>
          <label class="relative inline-flex items-center">
            <input type="checkbox" id="toggle-dims-switch" class="sr-only peer" checked>
            <div class="toggle-switch peer">
              <div class="toggle-slider"></div>
            </div>
          </label>
        </div>
        <input type="file" id="load-layout-input" class="hidden" accept=".json">
        <button id="load-btn" class="btn">Load</button>
        <button id="save-btn" class="btn">Save</button>
        <button id="delete-btn" class="btn" disabled>Delete</button>
      </div>
    </header>

    <div id="contextual-settings" class="flex items-center space-x-2 mb-4"></div>
    <div id="canvas" class="flex-1 flex items-center justify-center"></div>
  </main>

  <script>
document.addEventListener('DOMContentLoaded', async () => {
    const furnitureList = document.getElementById('furniture-list');
    const architecturalList = document.getElementById('architectural-list');
    const canvas = document.getElementById('canvas');
    const deleteBtn = document.getElementById('delete-btn');
    const saveBtn = document.getElementById('save-btn');
    const toggleDimsSwitch = document.getElementById('toggle-dims-switch');
    const loadBtn = document.getElementById('load-btn');
    const loadLayoutInput = document.getElementById('load-layout-input');
    const contextualSettings = document.getElementById('contextual-settings');
    const toggleSidebarBtn = document.getElementById('toggle-sidebar');
    const closeSidebarBtn = document.getElementById('close-sidebar');
    const floatingSidebar = document.getElementById('floating-sidebar');
    
    let roomContainer;
    let selectedObject = null;
    let objectCounter = 0;
    const furnitureRatios = {};
    const furnitureBounds = {};

    const furnitureCatalog = [
        { name: 'Bed', image: '/static/images/bed.png', width: 160, height: 200, zHeight: 55 },
        { name: 'Study Table', image: '/static/images/study_table.png', width: 120, height: 80, zHeight: 75 },
        { name: 'Sofa', image: '/static/images/sofa.png', width: 160, height: 110, zHeight: 85 },
        { name: 'Wardrobe', image: '/static/images/wardrobe.png', width: 150, height: 60, zHeight: 200 },
        { name: 'Study Chair', image: '/static/images/study_chair.png', width: 50, height: 50, zHeight: 42 },
        { name: 'Bedside Table', image: '/static/images/bedside_table.png', width: 60, height: 60, zHeight: 60 }
    ];

    const architecturalCatalog = [
        { name: 'Door', type: 'door', image: '/static/images/door.png', width: 90, openingHeight: 210 },
        { name: 'Window', type: 'window', image: '/static/images/window.png', width: 120, openingHeight: 100 }
    ];

    toggleSidebarBtn.addEventListener('click', () => {
        floatingSidebar.classList.toggle('hidden');
    });

    closeSidebarBtn.addEventListener('click', () => {
        floatingSidebar.classList.add('hidden');
    });

    async function precomputeBounds() {
        const promises = furnitureCatalog.map(item => new Promise(resolve => {
            const img = new Image();
            img.onload = () => {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = img.naturalWidth;
                tempCanvas.height = img.naturalHeight;
                tempCtx.drawImage(img, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                let minX = tempCanvas.width, minY = tempCanvas.height, maxX = 0, maxY = 0;
                for (let y = 0; y < tempCanvas.height; y++) {
                    for (let x = 0; x < tempCanvas.width; x++) {
                        const i = (y * tempCanvas.width + x) * 4;
                        if (data[i + 3] > 0) {
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                const boundsWidth = maxX - minX + 1;
                const boundsHeight = maxY - minY + 1;
                furnitureBounds[item.name] = { minX, minY, width: boundsWidth, height: boundsHeight, naturalScale: item.width / boundsWidth };
                furnitureRatios[item.name] = img.naturalHeight / img.naturalWidth;
                resolve();
            };
            img.onerror = () => {
                furnitureBounds[item.name] = { minX: 0, minY: 0, width: item.width, height: item.height, naturalScale: 1 };
                furnitureRatios[item.name] = item.height / item.width;
                resolve();
            };
            img.src = item.image;
        }));
        await Promise.all(promises);
    }

    function getRotationAngle(obj) {
        const match = obj.style.transform && obj.style.transform.match(/rotate\(([^deg]+)deg\)/);
        return match ? parseFloat(match[1]) : 0;
    }

    function updateFurnitureDimensionLabel(obj) {
        const dimDisplay = obj.querySelector('.dimension-display');
        if (!dimDisplay) return;
        const angle = getRotationAngle(obj);
        dimDisplay.textContent = `${Math.round(obj.offsetWidth)}x${Math.round(obj.offsetHeight)}x${obj.dataset.zHeight} cm (${Math.round(angle)}Â°)`;
    }

    function getVertices(obj) {
        const box = { x: obj.offsetLeft, y: obj.offsetTop, w: obj.offsetWidth, h: obj.offsetHeight };
        const angle = getRotationAngle(obj) * Math.PI / 180;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const cx = box.x + box.w / 2;
        const cy = box.y + box.h / 2;
        const vertices = [];
        for (let i = 0; i < 4; i++) {
            const w_half = (i < 2 ? box.w : -box.w) / 2;
            const h_half = (i % 3 === 0 ? box.h : -box.h) / 2;
            vertices.push({
                x: cx + (w_half * cos - h_half * sin),
                y: cy + (w_half * sin + h_half * cos)
            });
        }
        return vertices;
    }

    function checkCollision(obj1, obj2) {
        const v1 = getVertices(obj1);
        const v2 = getVertices(obj2);
        const axes = [v1[0].x - v1[1].x, v1[0].y - v1[1].y, v1[1].x - v1[2].x, v1[1].y - v1[2].y, v2[0].x - v2[1].x, v2[0].y - v2[1].y, v2[1].x - v2[2].x, v2[1].y - v2[2].y].map((val, i, arr) => i % 2 === 0 ? { x: -arr[i + 1], y: val } : null).filter(v => v);
        for (let axis of axes) {
            let p1 = v1.map(v => v.x * axis.x + v.y * axis.y);
            let p2 = v2.map(v => v.x * axis.x + v.y * axis.y);
            let min1 = Math.min(...p1), max1 = Math.max(...p1);
            let min2 = Math.min(...p2), max2 = Math.max(...p2);
            if (max1 < min2 || max2 < min1) return false;
        }
        return true;
    }

    function isOverlapping(movingObj, potentialState) {
        const clone = document.createElement('div');
        clone.style.position = 'absolute';
        clone.style.left = `${potentialState.x}px`;
        clone.style.top = `${potentialState.y}px`;
        clone.style.width = `${potentialState.width}px`;
        clone.style.height = `${potentialState.height}px`;
        clone.style.transform = `rotate(${potentialState.rotation}deg)`;
        const otherObjects = [...roomContainer.querySelectorAll('.furniture')].filter(child => child.id !== (movingObj && movingObj.id));
        for (let other of otherObjects) {
            if (checkCollision(clone, other)) return true;
        }
        return false;
    }

    function populateSidebar() {
        [furnitureList, architecturalList].forEach(list => list.innerHTML = '');
        const createSidebarItem = (item) => {
            const div = document.createElement('div');
            div.className = 'bg-slate-800 hover:bg-slate-700 p-3 rounded-lg cursor-grab flex flex-col items-center shadow-sm border border-slate-700 transition hover:shadow-md hover:scale-105';
            div.draggable = true;
            div.dataset.item = JSON.stringify(item);
            const bounds = furnitureBounds[item.name] || { width: item.width, height: item.height };
            const aspectRatio = bounds.height / bounds.width;
            const baseWidth = 80;
            const scaledHeight = Math.max(40, baseWidth * aspectRatio);
            div.innerHTML = `<div class="sidebar-icon" style="width:${baseWidth + 16}px;height:${scaledHeight + 16}px;"><img src="${item.image}" style="width:${baseWidth}px;height:${scaledHeight}px;object-fit:contain;" draggable="false" /></div><span class="font-medium text-sm text-slate-200 mt-2">${item.name}</span>`;
            div.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', e.currentTarget.dataset.item));
            return div;
        };
        furnitureCatalog.forEach(item => furnitureList.appendChild(createSidebarItem(item)));
        architecturalCatalog.forEach(item => architecturalList.appendChild(createSidebarItem(item)));
    }

    function addFurnitureEventListeners(obj) {
        const rotateHandle = obj.querySelector('.rotate-handle');
        const resizeHandle = obj.querySelector('.resize-handle');

        obj.addEventListener('mousedown', e => {
            if (e.target.classList.contains('furniture') || e.target.closest('.furniture')) {
                if (!e.target.classList.contains('resize-handle') && !e.target.classList.contains('rotate-handle')) {
                    selectObject(obj);
                    let isDragging = true;
                    const startMouseX = e.clientX;
                    const startMouseY = e.clientY;
                    const startCenterX = obj.offsetLeft + obj.offsetWidth / 2;
                    const startCenterY = obj.offsetTop + obj.offsetHeight / 2;
                    document.body.style.cursor = 'move';
                    e.stopPropagation();
                    function dragMove(e) {
                        if (!isDragging) return;
                        let newCenterX = startCenterX + (e.clientX - startMouseX);
                        let newCenterY = startCenterY + (e.clientY - startMouseY);
                        const angleRad = getRotationAngle(obj) * Math.PI / 180;
                        const w = obj.offsetWidth;
                        const h = obj.offsetHeight;
                        const rotatedHalfWidth = (Math.abs(Math.cos(angleRad)) * w + Math.abs(Math.sin(angleRad)) * h) / 2;
                        const rotatedHalfHeight = (Math.abs(Math.sin(angleRad)) * w + Math.abs(Math.cos(angleRad)) * h) / 2;
                        newCenterX = Math.max(rotatedHalfWidth, Math.min(newCenterX, roomContainer.offsetWidth - rotatedHalfWidth));
                        newCenterY = Math.max(rotatedHalfHeight, Math.min(newCenterY, roomContainer.offsetHeight - rotatedHalfHeight));
                        const potentialState = { x: newCenterX - w / 2, y: newCenterY - h / 2, width: w, height: h, rotation: getRotationAngle(obj) };
                        if (!isOverlapping(obj, potentialState)) {
                            obj.style.left = `${potentialState.x}px`;
                            obj.style.top = `${potentialState.y}px`;
                            obj.classList.remove('colliding');
                        } else {
                            obj.classList.add('colliding');
                        }
                    }
                    function dragEnd() {
                        isDragging = false;
                        obj.classList.remove('colliding');
                        document.body.style.cursor = 'default';
                        document.removeEventListener('mousemove', dragMove);
                        document.removeEventListener('mouseup', dragEnd);
                    }
                    document.addEventListener('mousemove', dragMove);
                    document.addEventListener('mouseup', dragEnd);
                }
            }
        });

        resizeHandle.addEventListener('mousedown', e => {
            e.stopPropagation();
            selectObject(obj);
            let isResizing = true;
            const startWidth = obj.offsetWidth;
            const startHeight = obj.offsetHeight;
            const startMouseX = e.clientX;
            const startMouseY = e.clientY;
            const img = obj.querySelector('img');
            const startImgWidth = parseFloat(img.style.width) || img.naturalWidth;
            const startImgHeight = parseFloat(img.style.height) || img.naturalHeight;
            function resizeMove(e) {
                if (!isResizing) return;
                const newWidth = startWidth + (e.clientX - startMouseX);
                const newHeight = startHeight + (e.clientY - startMouseY);
                const potentialState = { x: obj.offsetLeft, y: obj.offsetTop, width: newWidth, height: newHeight, rotation: getRotationAngle(obj) };
                if (!isOverlapping(obj, potentialState)) {
                    obj.style.width = `${Math.max(20, newWidth)}px`;
                    obj.style.height = `${Math.max(20, newHeight)}px`;
                    img.style.width = `${startImgWidth * (newWidth / startWidth)}px`;
                    img.style.height = `${startImgHeight * (newHeight / startHeight)}px`;
                    updateFurnitureDimensionLabel(obj);
                    obj.classList.remove('colliding');
                } else {
                    obj.classList.add('colliding');
                }
            }
            function resizeEnd() {
                isResizing = false;
                obj.classList.remove('colliding');
                document.removeEventListener('mousemove', resizeMove);
                document.removeEventListener('mouseup', resizeEnd);
            }
            document.addEventListener('mousemove', resizeMove);
            document.addEventListener('mouseup', resizeEnd);
        });

        rotateHandle.addEventListener('mousedown', e => {
            e.stopPropagation();
            selectObject(obj);
            let isRotating = true;
            const startAngle = getRotationAngle(obj);
            const startMouseX = e.clientX;
            const startMouseY = e.clientY;
            const rect = obj.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const startMouseAngle = Math.atan2(startMouseY - centerY, startMouseX - centerX) * (180 / Math.PI);
            function rotateMove(e) {
                if (!isRotating) return;
                const currentMouseX = e.clientX;
                const currentMouseY = e.clientY;
                const currentMouseAngle = Math.atan2(currentMouseY - centerY, currentMouseX - centerX) * (180 / Math.PI);
                const rawRotation = startAngle + (currentMouseAngle - startMouseAngle);
                let finalRotation = rawRotation;
                let isSnapped = false;
                for (let angle of [0, 90, 180, 270, 360, -90, -180, -270]) {
                    if (Math.abs(rawRotation - angle) < 10) {
                        finalRotation = angle % 360;
                        isSnapped = true;
                        break;
                    }
                }
                const potentialState = { x: obj.offsetLeft, y: obj.offsetTop, width: obj.offsetWidth, height: obj.offsetHeight, rotation: finalRotation };
                if (!isOverlapping(obj, potentialState)) {
                    rotateHandle.classList.toggle('snapped', isSnapped);
                    obj.style.transform = `rotate(${finalRotation}deg)`;
                    updateFurnitureDimensionLabel(obj);
                    obj.classList.remove('colliding');
                } else {
                    obj.classList.add('colliding');
                }
            }
            function rotateEnd() {
                isRotating = false;
                rotateHandle.classList.remove('snapped');
                obj.classList.remove('colliding');
                document.removeEventListener('mousemove', rotateMove);
                document.removeEventListener('mouseup', rotateEnd);
            }
            document.addEventListener('mousemove', rotateMove);
            document.addEventListener('mouseup', rotateEnd);
        });
    }

    function addWallFeatureEventListeners(obj) {
        let action = null;
        let startMousePos, startObjPos, startSize;
        const isVertical = obj.classList.contains('on-vertical-wall');
        obj.addEventListener('mousemove', e => {
            if (action) return;
            const rect = obj.getBoundingClientRect();
            const clickPos = isVertical ? e.clientY : e.clientX;
            const startEdge = isVertical ? rect.top : rect.left;
            const endEdge = isVertical ? rect.bottom : rect.right;
            obj.style.cursor = (Math.abs(clickPos - startEdge) < 10 || Math.abs(clickPos - endEdge) < 10) ? (isVertical ? 'ns-resize' : 'ew-resize') : 'move';
        });
        obj.addEventListener('mousedown', e => {
            e.stopPropagation();
            selectObject(obj);
            const rect = obj.getBoundingClientRect();
            const clickPos = isVertical ? e.clientY : e.clientX;
            const startEdge = isVertical ? rect.top : rect.left;
            const endEdge = isVertical ? rect.bottom : rect.right;
            if (Math.abs(clickPos - startEdge) < 10) action = 'resize-start';
            else if (Math.abs(clickPos - endEdge) < 10) action = 'resize-end';
            else action = 'drag';
            startMousePos = isVertical ? e.clientY : e.clientX;
            startObjPos = isVertical ? obj.offsetTop : obj.offsetLeft;
            startSize = isVertical ? obj.offsetHeight : obj.offsetWidth;
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
        function onMouseMove(e) {
            if (!action) return;
            e.preventDefault();
            const currentMousePos = isVertical ? e.clientY : e.clientX;
            const delta = currentMousePos - startMousePos;
            if (action === 'drag') {
                if (isVertical) {
                    let newTop = startObjPos + delta;
                    newTop = Math.max(0, Math.min(newTop, roomContainer.offsetHeight - obj.offsetHeight));
                    obj.style.top = `${newTop}px`;
                } else {
                    let newLeft = startObjPos + delta;
                    newLeft = Math.max(0, Math.min(newLeft, roomContainer.offsetWidth - obj.offsetWidth));
                    obj.style.left = `${newLeft}px`;
                }
            } else {
                if (isVertical) {
                    if (action === 'resize-start') {
                        const newHeight = startSize - delta;
                        if (newHeight > 30) {
                            obj.style.height = `${newHeight}px`;
                            obj.style.top = `${startObjPos + delta}px`;
                        }
                    } else {
                        const newHeight = startSize + delta;
                        if (newHeight > 30) obj.style.height = `${newHeight}px`;
                    }
                } else {
                    if (action === 'resize-start') {
                        const newWidth = startSize - delta;
                        if (newWidth > 30) {
                            obj.style.width = `${newWidth}px`;
                            obj.style.left = `${startObjPos + delta}px`;
                        }
                    } else {
                        const newWidth = startSize + delta;
                        if (newWidth > 30) obj.style.width = `${newWidth}px`;
                    }
                }
                updateWallFeatureDimensionLabel(obj);
            }
        }
        function onMouseUp() {
            action = null;
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }
    }

    function updateWallFeatureDimensionLabel(obj) {
        const dimDisplay = obj.querySelector('.dimension-display');
        if (!dimDisplay) return;
        const width = obj.classList.contains('on-vertical-wall') ? obj.offsetHeight : obj.offsetWidth;
        if (obj.classList.contains('window')) {
            dimDisplay.textContent = `W:${width}, H:${obj.dataset.openingHeight}, Sill:${obj.dataset.heightFromGround} cm`;
        } else {
            dimDisplay.textContent = `W:${width}, H:${obj.dataset.openingHeight} cm`;
        }
    }

    function updateRoomDimensions() {
        const display = roomContainer.querySelector('.room-dimension');
        if (display) display.textContent = `${roomContainer.offsetWidth} x ${roomContainer.offsetHeight} cm`;
    }

    function updateWallFeaturesPosition() {
        roomContainer.querySelectorAll('.wall-feature').forEach(obj => {
            const wall = obj.dataset.wall;
            const isVertical = obj.classList.contains('on-vertical-wall');
            if (wall === 'bottom') obj.style.top = `${roomContainer.offsetHeight - 5}px`;
            else if (wall === 'right') obj.style.left = `${roomContainer.offsetWidth - 5}px`;
            if (!isVertical) {
                const maxLeft = roomContainer.offsetWidth - obj.offsetWidth;
                if (obj.offsetLeft > maxLeft) obj.style.left = `${maxLeft}px`;
            } else {
                const maxTop = roomContainer.offsetHeight - obj.offsetHeight;
                if (obj.offsetTop > maxTop) obj.style.top = `${maxTop}px`;
            }
        });
    }

    function selectObject(obj) {
        if (selectedObject) selectedObject.classList.remove('selected');
        selectedObject = obj;
        contextualSettings.innerHTML = '';
        if (!obj) {
            deleteBtn.disabled = true;
            return;
        }
        selectedObject.classList.add('selected');
        deleteBtn.disabled = false;
        if (obj.classList.contains('furniture')) {
            contextualSettings.innerHTML = `<label for="cs-height" class="text-sm text-slate-200 mr-2">Height(cm):</label><input type="number" id="cs-height" class="w-20 border-gray-300 rounded-md shadow-sm text-sm bg-slate-700 text-white border-slate-600 px-2 py-1" value="${obj.dataset.zHeight}"><button id="cs-set-height" class="px-3 py-1 bg-blue-500 text-white text-xs rounded ml-2 hover:bg-blue-600">Set</button>`;
            document.getElementById('cs-set-height').addEventListener('click', () => {
                obj.dataset.zHeight = document.getElementById('cs-height').value;
                updateFurnitureDimensionLabel(obj);
            });
        } else if (obj.classList.contains('window')) {
            contextualSettings.innerHTML = `<label for="cs-sill" class="text-sm text-slate-200 mr-2">Sill(cm):</label><input type="number" id="cs-sill" class="w-20 border-gray-300 rounded-md text-sm bg-slate-700 text-white border-slate-600 px-2 py-1" value="${obj.dataset.heightFromGround}"><label for="cs-o-height" class="text-sm text-slate-200 ml-2 mr-2">Height(cm):</label><input type="number" id="cs-o-height" class="w-20 border-gray-300 rounded-md text-sm bg-slate-700 text-white border-slate-600 px-2 py-1" value="${obj.dataset.openingHeight}">`;
            document.getElementById('cs-sill').addEventListener('change', e => {
                obj.dataset.heightFromGround = e.target.value;
                updateWallFeatureDimensionLabel(obj);
            });
            document.getElementById('cs-o-height').addEventListener('change', e => {
                obj.dataset.openingHeight = e.target.value;
                updateWallFeatureDimensionLabel(obj);
            });
        } else if (obj.classList.contains('door')) {
            contextualSettings.innerHTML = `<label for="cs-o-height" class="text-sm text-slate-200 mr-2">Height(cm):</label><input type="number" id="cs-o-height" class="w-20 border-gray-300 rounded-md text-sm bg-slate-700 text-white border-slate-600 px-2 py-1" value="${obj.dataset.openingHeight}"><button id="cs-set-o-height" class="px-3 py-1 bg-blue-500 text-white text-xs rounded ml-2 hover:bg-blue-600">Set</button>`;
            document.getElementById('cs-set-o-height').addEventListener('click', () => {
                obj.dataset.openingHeight = document.getElementById('cs-o-height').value;
                updateWallFeatureDimensionLabel(obj);
            });
        }
    }

    const deselectAll = () => selectObject(null);

    function findClosestWall(x, y, roomWidth, roomHeight) {
        const dists = { top: y, bottom: roomHeight - y, left: x, right: roomWidth - x };
        const closest = Object.keys(dists).reduce((a, b) => dists[a] < dists[b] ? a : b);
        let position = (closest === 'top' || closest === 'bottom') ? x : y;
        return { name: closest, position: position };
    }

    function createFurnitureObject(itemData, pos, loaded = false) {
        objectCounter++;
        const obj = document.createElement('div');
        obj.id = `object-${objectCounter}`;
        obj.className = 'furniture';
        obj.dataset.name = itemData.name;
        obj.dataset.zHeight = itemData.zHeight;
        obj.style.left = `${pos.x}px`;
        obj.style.top = `${pos.y}px`;
        obj.style.transform = `rotate(${pos.rotation || 0}deg)`;

        obj.innerHTML = `<div class="handle resize-handle"></div><div class="handle rotate-handle"></div><div class="dimension-display"></div>`;

        const img = document.createElement('img');
        img.src = itemData.image;
        img.alt = itemData.name;
        img.style.position = 'absolute';
        img.style.top = '0';
        img.style.left = '0';
        obj.appendChild(img);

        const bounds = furnitureBounds[itemData.name];
        if (bounds) {
            const scale = itemData.width / bounds.width;
            obj.style.width = `${itemData.width}px`;
            obj.style.height = `${bounds.height * scale}px`;
            img.style.width = `${img.naturalWidth * scale}px`;
            img.style.height = `${img.naturalHeight * scale}px`;
            img.style.left = `${-bounds.minX * scale}px`;
            img.style.top = `${-bounds.minY * scale}px`;
        } else {
            obj.style.width = `${itemData.width}px`;
            obj.style.height = `${itemData.height}px`;
        }

        img.onload = () => {
            if (!bounds) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = img.naturalWidth;
                tempCanvas.height = img.naturalHeight;
                tempCtx.drawImage(img, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const data = imageData.data;
                let minX = tempCanvas.width, minY = tempCanvas.height, maxX = 0, maxY = 0;
                for (let y = 0; y < tempCanvas.height; y++) {
                    for (let x = 0; x < tempCanvas.width; x++) {
                        const i = (y * tempCanvas.width + x) * 4;
                        if (data[i + 3] > 0) {
                            minX = Math.min(minX, x);
                            minY = Math.min(minY, y);
                            maxX = Math.max(maxX, x);
                            maxY = Math.max(maxY, y);
                        }
                    }
                }
                const bWidth = maxX - minX + 1;
                const bHeight = maxY - minY + 1;
                const scale = itemData.width / bWidth;
                obj.style.width = `${itemData.width}px`;
                obj.style.height = `${bHeight * scale}px`;
                img.style.width = `${img.naturalWidth * scale}px`;
                img.style.height = `${img.naturalHeight * scale}px`;
                img.style.left = `${-minX * scale}px`;
                img.style.top = `${-minY * scale}px`;
                furnitureBounds[itemData.name] = { minX, minY, width: bWidth, height: bHeight };
            }
            updateFurnitureDimensionLabel(obj);
        };

        roomContainer.appendChild(obj);
        addFurnitureEventListeners(obj);
        if (!loaded) selectObject(obj);
    }

    function createWallFeature(type, options = {}) {
        objectCounter++;
        const feature = document.createElement('div');
        feature.id = `object-${objectCounter}`;
        feature.className = `wall-feature ${type}`;
        feature.dataset.name = type;

        const wall = options.wall || 'top';
        feature.dataset.wall = wall;

        feature.dataset.openingHeight = options.openingHeight || (type === 'door' ? 210 : 100);
        if (type === 'window') feature.dataset.heightFromGround = options.heightFromGround || 90;

        feature.innerHTML = `<div class="dimension-display"></div>`;

        if (type === 'door') {
            feature.style.background = 'linear-gradient(to right, #3b82f6 0%, #1e3a8a 100%)';
            feature.style.border = '2px solid #60a5fa';
            feature.style.borderRadius = '3px';
            feature.style.boxShadow = '0 0 8px rgba(59,130,246,0.5)';
        } else if (type === 'window') {
            feature.style.background = 'linear-gradient(145deg, #38bdf8 0%, #0ea5e9 100%)';
            feature.style.border = '2px solid #7dd3fc';
            feature.style.borderRadius = '3px';
            feature.style.boxShadow = '0 0 8px rgba(56,189,248,0.5)';
        }

        const wallThickness = 10;
        if (wall === 'top' || wall === 'bottom') {
            feature.style.width = `${options.size || (type === 'door' ? 90 : 120)}px`;
            feature.style.height = `${wallThickness}px`;
            const position = Math.max(0, Math.min(options.position || 100, roomContainer.offsetWidth - (options.size || 120)));
            feature.style.left = `${position}px`;
            feature.style.top = wall === 'top' ? `-${wallThickness / 2}px` : `${roomContainer.offsetHeight - wallThickness / 2}px`;
        } else {
            feature.classList.add('on-vertical-wall');
            feature.style.height = `${options.size || (type === 'door' ? 90 : 120)}px`;
            feature.style.width = `${wallThickness}px`;
            const position = Math.max(0, Math.min(options.position || 100, roomContainer.offsetHeight - (options.size || 120)));
            feature.style.top = `${position}px`;
            feature.style.left = wall === 'left' ? `-${wallThickness / 2}px` : `${roomContainer.offsetWidth - wallThickness / 2}px`;
        }

        roomContainer.appendChild(feature);
        addWallFeatureEventListeners(feature);
        updateWallFeatureDimensionLabel(feature);
        selectObject(feature);
    }

    function handleDrop(e) {
        e.preventDefault();
        const itemData = JSON.parse(e.dataTransfer.getData('text/plain'));
        const roomRect = roomContainer.getBoundingClientRect();
        const x = e.clientX - roomRect.left;
        const y = e.clientY - roomRect.top;
        if (itemData.type === 'door' || itemData.type === 'window') {
            const closestWall = findClosestWall(x, y, roomContainer.offsetWidth, roomContainer.offsetHeight);
            createWallFeature(itemData.type, { wall: closestWall.name, position: closestWall.position - (itemData.width / 2) });
        } else {
            const bounds = furnitureBounds[itemData.name];
            const adjHeight = bounds ? (itemData.width / bounds.width) * bounds.height : itemData.height;
            const pos = { x: x - (itemData.width / 2), y: y - (adjHeight / 2), rotation: 0 };
            const checkState = { x: pos.x, y: pos.y, width: itemData.width, height: adjHeight, rotation: 0 };
            if (!isOverlapping(null, checkState)) {
                createFurnitureObject(itemData, pos);
            } else {
                console.warn("Cannot place object here: Overlap detected.");
            }
        }
    }

    function addRoomResizeListener(handle, position) {
        handle.addEventListener('mousedown', e => {
            e.stopPropagation();
            let isResizing = true;
            const startX = e.clientX;
            const startY = e.clientY;
            const startWidth = roomContainer.offsetWidth;
            const startHeight = roomContainer.offsetHeight;
            document.body.style.cursor = handle.style.cursor;
            function resizeMove(e) {
                if (!isResizing) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                let newWidth = startWidth;
                let newHeight = startHeight;
                if (position.includes('right')) newWidth += dx;
                if (position.includes('left')) newWidth -= dx;
                if (position.includes('bottom')) newHeight += dy;
                if (position.includes('top')) newHeight -= dy;
                roomContainer.style.width = `${Math.max(200, newWidth)}px`;
                roomContainer.style.height = `${Math.max(200, newHeight)}px`;
                updateRoomDimensions();
                updateWallFeaturesPosition();
            }
            function resizeEnd() {
                isResizing = false;
                document.body.style.cursor = 'default';
                document.removeEventListener('mousemove', resizeMove);
                document.removeEventListener('mouseup', resizeEnd);
            }
            document.addEventListener('mousemove', resizeMove);
            document.addEventListener('mouseup', resizeEnd);
        });
    }

    function saveLayout() {
        const layoutData = { room: { width: roomContainer.offsetWidth, height: roomContainer.offsetHeight }, furniture: [], openings: [] };
        roomContainer.querySelectorAll('.furniture').forEach(obj => {
            const img = obj.querySelector('img');
            layoutData.furniture.push({ 
                name: obj.dataset.name, 
                x: obj.offsetLeft, 
                y: obj.offsetTop, 
                width: obj.offsetWidth, 
                height: obj.offsetHeight, 
                zHeight: obj.dataset.zHeight, 
                rotation: getRotationAngle(obj),
                imgLeft: img.style.left,
                imgTop: img.style.top,
                imgWidth: img.style.width,
                imgHeight: img.style.height
            });
        });
        roomContainer.querySelectorAll('.wall-feature').forEach(obj => {
            const isVertical = obj.classList.contains('on-vertical-wall');
            const opening = { type: obj.dataset.name, wall: obj.dataset.wall, position: isVertical ? obj.offsetTop : obj.offsetLeft, size: isVertical ? obj.offsetHeight : obj.offsetWidth, openingHeight: obj.dataset.openingHeight };
            if (opening.type === 'window') opening.heightFromGround = obj.dataset.heightFromGround;
            layoutData.openings.push(opening);
        });
        const blob = new Blob([JSON.stringify(layoutData, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'room-layout.json';
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function buildLayoutFromJSON(data) {
        deselectAll();
        canvas.innerHTML = '';
        initializeApp(data.room.width, data.room.height);
        (data.openings || []).forEach(o => createWallFeature(o.type, o));
        (data.furniture || []).forEach((f) => {
            const catalogItem = furnitureCatalog.find(item => item.name === f.name);
            if (catalogItem) {
                const itemData = { ...catalogItem, width: f.width, height: f.height, zHeight: f.zHeight };
                const pos = { x: f.x, y: f.y, rotation: f.rotation };
                createFurnitureObject(itemData, pos, true);
                setTimeout(() => {
                    const obj = roomContainer.querySelector(`[data-name="${f.name}"]:last-of-type`);
                    if (obj) {
                        const img = obj.querySelector('img');
                        if (f.imgLeft) img.style.left = f.imgLeft;
                        if (f.imgTop) img.style.top = f.imgTop;
                        if (f.imgWidth) img.style.width = f.imgWidth;
                        if (f.imgHeight) img.style.height = f.imgHeight;
                        updateFurnitureDimensionLabel(obj);
                    }
                }, 100);
            }
        });
        deselectAll();
    }

    function initializeApp(width = 800, height = 600) {
        canvas.innerHTML = '';
        roomContainer = document.createElement('div');
        roomContainer.id = 'room-container';
        roomContainer.style.width = `${width}px`;
        roomContainer.style.height = `${height}px`;
        roomContainer.style.backgroundImage = "linear-gradient(to right, #334155 1px, transparent 1px), linear-gradient(to bottom, #334155 1px, transparent 1px)";
        roomContainer.style.backgroundSize = "40px 40px";
        canvas.appendChild(roomContainer);
        const roomDimDisplay = document.createElement('div');
        roomDimDisplay.className = 'dimension-display room-dimension';
        roomContainer.appendChild(roomDimDisplay);
        updateRoomDimensions();
        ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach(pos => {
            const handle = document.createElement('div');
            handle.className = `handle room-handle ${pos}`;
            roomContainer.appendChild(handle);
            addRoomResizeListener(handle, pos);
        });
        roomContainer.addEventListener('dragover', e => e.preventDefault());
        roomContainer.addEventListener('drop', handleDrop);
    }

    deleteBtn.addEventListener('click', () => {
        if (selectedObject) {
            selectedObject.remove();
            deselectAll();
        }
    });

    canvas.addEventListener('click', e => {
        if (e.target.id === 'canvas' || e.target.id === 'room-container') deselectAll();
    });

    loadBtn.addEventListener('click', () => loadLayoutInput.click());
    loadLayoutInput.addEventListener('change', e => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (re) => {
                try {
                    buildLayoutFromJSON(JSON.parse(re.target.result));
                } catch (err) {
                    alert('Error: Could not load layout from file.');
                    console.error(err);
                }
            };
            reader.readAsText(file);
            e.target.value = null;
        }
    });

    saveBtn.addEventListener('click', saveLayout);
    toggleDimsSwitch.addEventListener('change', () => document.body.classList.toggle('hide-dims', !toggleDimsSwitch.checked));

    await precomputeBounds();
    populateSidebar();
    initializeApp();
});
  </script>
</body>
</html>